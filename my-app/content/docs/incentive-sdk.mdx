---
title: Incentive SDK
description: Client utilities for reading LiquidLink scoreboards on Sui/IOTA. Built on top of `unimove-sdk`.
---

## Overview

`liquidlink-sdk` is a thin TypeScript wrapper that understands LiquidLink scoreboards (regular + linear) and exposes a chain-aware client powered by `unimove-sdk`. It knows the object layout, supplies zero-safe defaults, and provides helpers for pulling event logs so integrators can ship dashboards or bots quickly.

### Installation

```bash
npm install liquidlink-sdk
```

## Quick example

```ts
import { Client } from 'liquidlink-sdk';

const TARGET_ADDRESS = '0x...';
const REGULAR_SCOREBOARD_ID = '0x...';
const LINEAR_SCOREBOARD_ID = '0x...';

const sdk = new Client({ chain: 'iota', network: 'testnet' });

console.log('Regular score info', await sdk.getScoreInfo({
  scoreboardId: REGULAR_SCOREBOARD_ID,
  targetAddress: TARGET_ADDRESS,
}));

console.log('Regular computed score', await sdk.getComputedScore({
  scoreboardId: REGULAR_SCOREBOARD_ID,
  targetAddress: TARGET_ADDRESS,
  opts: { linear: false },
}));

console.log('Linear computed score', await sdk.getComputedScore({
  scoreboardId: LINEAR_SCOREBOARD_ID,
  targetAddress: TARGET_ADDRESS,
  opts: { linear: true },
}));

console.log('Event types', sdk.getAvailableEventTypes());

console.log('Recent events', await sdk.getEventsByAddress({
  targetAddress: TARGET_ADDRESS,
  scoreboardIds: [REGULAR_SCOREBOARD_ID, LINEAR_SCOREBOARD_ID],
  limit: 5,
}));
```

## API reference

### `new Client({ chain, network, rpcUrl? })`

Creates a client for a specific chain/network. `chain` is `"sui"` or `"iota"`, `network` defaults to `"mainnet"`, and `rpcUrl` overrides the fullnode URL returned by `unimove-sdk`.

### `getClient()`

Returns the underlying Sui/IOTA SDK client so you can run low-level RPC calls alongside the helpers.

### `getConfig()`

Returns the selected block from `CONFIG` (package IDs, router references, etc.).

### `getAvailableEventTypes()`

Returns the four fully-qualified Move event types emitted by the incentive package (add/subtract/set/update). Useful when building filters for `getEventsByAddress`.

### `getScoreInfo({ scoreboardId, targetAddress })`

Reads the scoreboard table entry for `targetAddress`. If no entry exists the SDK returns:

```ts
{ duration: 0, score: 0, scorePerDuration: 0, updatedAt: 0 }
```

so the rest of your code can treat “not found” as zeros.

### `getComputedScore({ scoreboardId, targetAddress, opts })`

Wraps `getScoreInfo` and optionally computes a client-side linear projection:

- When `opts.linear` is `true` and both `duration` and `scorePerDuration` are positive, it calculates  
  `score + (scorePerDuration * (Date.now() - updatedAt)) / duration`.
- Otherwise it simply returns the stored `score`.

The response always includes `{ computedScore, score, scorePerDuration, duration, updatedAt }`.

### `getEventsByAddress({ targetAddress, eventTypes?, scoreboardId?, scoreboardIds?, cursor?, limit?, order? })`

Fetches events by sender address and filters the payload on the client:

- Provide either `scoreboardId` or `scoreboardIds` (it throws if neither is supplied).
- `eventTypes` lets you narrow the results to specific Move event types (use `getAvailableEventTypes()` to build the list).
- `cursor`, `limit`, and `order` follow the underlying RPC pagination semantics (`order` defaults to `"descending"`).

The helper keeps only events whose `parsedJson.scoreboard_id` matches the provided IDs and returns `{ data, cursor, hasNextPage }`.

## Tips

- **Zero-safe lookups:** Treat zeroed fields as “no prior points” rather than an error.
- **Linear UI widgets:** Poll `getComputedScore` with `opts.linear` when you need a live-updating staking indicator.
- **Event history:** `getEventsByAddress` is ideal for user-centric history views; for protocol-wide analytics, pair it with your own indexer and batching logic.
